<!DOCTYPE html>
<html>
  <head>
    <title>Colorizor - Test</title>
    <script type="text/javascript" src="https://colorizor.github.io/colorizor.js?theme=Salmon" async></script>
  </head>
  <body>
    <main>
      <pre><code language="css">/*----------------------------------------Dark----------------------------------------*/
pre {
  background-color:rgb(88, 88, 88);
  color:rgb(232, 200, 178);
  font-family:"Lucida Console", Monaco, monospace;
  font-size:14px;
  font-style:bold;
  height:auto;margin:5px;
  overflow:auto; padding:10px;
  text-align:left;
  -webkit-text-size-adjust:none;-moz-text-size-adjust:none;-ms-text-size-adjust:none;
}

sdfsdf http://colorizor.github.io/colorizor.js rger

#text{background-color:rgb(255, 248, 207);color:rgb(232, 200, 178);font-family:"Lucida Console", Monaco, monospace;font-size:12px;font-style:bold;height:auto;width:auto;z-index:100;}
#all-number{border-right:1px solid rgb(232, 200, 178);display:inline-block;float:left;margin-right:8px;text-align:right;}

#all-code[sdsd="sdsd"],
.sdds,
sdds {
  display: inline-block;
  float: top;
  margin-left: 8px;
  text-align: left;
}

#number{color:rgb(232, 200, 178);float:top;padding-right:4px;}
#code{float:top;}
#link{color:rgb(150, 150, 150);font-style:underline;}
#regx{color:rgb(150, 150, 150);}
#units{color:rgb(150, 150, 150);}
#comment{color:rgb(205, 255, 214);font-style:italic;}
#selector{color:rgb(255, 248, 207);}
#attribute{color:rgb(173, 176, 232);}
#value{color:rgb(193, 222, 255);}
#parameter{color:rgb(232, 200, 178);}</code></pre>
<br /><br />
<pre><code language="javascript">(function() {
  //----------------------------------------------------------------------------------------------------------
  //--------------------------------------------------LoadJS--------------------------------------------------
  //----------------------------------------------------------------------------------------------------------
  function loadJS(src, cb) {
    var ref = window.document.getElementsByTagName('script')[0];
    var script = window.document.createElement('script');
    script.src = src;
    script.async = true;
    ref.parentNode.insertBefore(script, ref);
    if (cb && typeof(cb) === 'function') {
      script.onload = cb;
    }
    return script;
  }
  //----------------------------------------------------------------------------------------------------------
  //--------------------------------------------------LoadCSS-------------------------------------------------
  //----------------------------------------------------------------------------------------------------------
  function loadCSS(href, before, media, callback) {
    var ss = window.document.createElement('link');
    var ref = before || window.document.getElementsByTagName('script')[0];
    var sheets = window.document.styleSheets;
    ss.rel = 'stylesheet';
    ss.href = href;
    ss.media = 'only x';
    if (callback) {
      ss.onload = callback;
    }
    ref.parentNode.insertBefore(ss, ref);
    ss.onloadcssdefined = function(cb) {
      var defined;
      for (var i = 0; i &lt; sheets.length; i++) {
        if (sheets[i].href && sheets[i].href.indexOf(href) &gt; -1) {
          defined = true;
        }
      }
      if (defined) {
        cb();
      } else {
        setTimeout(function() {
          ss.onloadcssdefined(cb);
        });
      }
    };
    ss.onloadcssdefined(function() {
      ss.media = media || 'all';
    });
    return ss;
  }
  //----------------------------------------------------------------------------------------------------------
  //-----------------------------------------Load jQuery If Not Present---------------------------------------
  //----------------------------------------------------------------------------------------------------------
  if (typeof jQuery == 'undefined') {
    loadJS('https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js');
  }
  //----------------------------------------------------------------------------------------------------------
  //----------------------------------------------Wait For jQuery---------------------------------------------
  //----------------------------------------------------------------------------------------------------------
  var waitForLoad = function() {
    if (typeof jQuery != 'undefined') {
      //----------------------------------------------------------------------------------------------------------
      //-----------------------------------------------Load Language----------------------------------------------
      //----------------------------------------------------------------------------------------------------------
      $.each($('pre'), function() {
        var language = $(this).attr('language');
        loadJS('https://colorizor.github.io/Languages/' + language.toLowerCase() + '.js');
      });
      //----------------------------------------------------------------------------------------------------------
      //------------------------------------------Checking URL Parameters-----------------------------------------
      //----------------------------------------------------------------------------------------------------------
      $.each($('script'), function() {
        var url = $(this).attr('src');
        var path = /\/colorizor\.js\?theme\=/igm;
        if (path.test(url)) {
          var theme = url.split('theme=')[1];
          loadCSS('https://colorizor.github.io/Themes/' + theme.toLowerCase() + '.css');
        }
      });
    } else {
      window.setTimeout(waitForLoad, 60);
    }
  };
  window.setTimeout(waitForLoad, 60);
})();</code></pre>
<br /><br />
<pre><code language="swift">/*

Copyright Reserved For HovyTech



The code may be modified, but when referred to in any form please acknowledge that it was originally created by HovyTech.



Hope you find it useful

*/

import Foundation
import QuartzCore

//==============================================================================================
//========================================Delegate Setup========================================
//==============================================================================================
@objc protocol HTFTPStuffDelegate {

    optional func HTOpening(isDownload: Bool)
    optional func HTOpen(isDownload: Bool)
    optional func HTDownload(bytesRead: Int, totalBytesRead: Int, totalBytesExpectedToRead: Int)
    optional func HTUpload(bytesWritten: Int, totalBytesWritten: Int, totalBytesExpectedToWrite: Int)
    optional func HTClose(isDownload: Bool)
    optional func HTComplete(isDownload: Bool)
    optional func HTError(isDownload: Bool, error: NSStreamEvent)
    optional func HTUnknown(isDownload: Bool, event: NSStreamEvent)

}

class HTFTPStuff: NSObject, NSStreamDelegate {

    //==============================================================================================
    //===========================================Variables==========================================
    //==============================================================================================
    var delegate: HTFTPStuffDelegate!

    private var downloadURL: NSURL
    private var uploadURL: NSURL
    private var data: NSData

    private var username: String
    private var password: String

    private var totalBytesRead: Int
    private var totalBytesWritten: Int

    private var currentStream: NSStream?
    private var isDownload: Bool?

    //==============================================================================================
    //==========================================Initiation==========================================
    //==============================================================================================
    init(downloadPath: String) {
        self.downloadURL = NSURL(string: downloadPath)!
        self.uploadURL = NSURL()
        self.data = NSData()

        self.username = ""
        self.password = ""

        self.totalBytesRead = 0
        self.totalBytesWritten = 0
        super.init()
    }

    init(uploadPath: String, data: NSData) {
        self.downloadURL = NSURL()
        self.uploadURL = NSURL(string: uploadPath)!
        self.data = data

        self.username = ""
        self.password = ""

        self.totalBytesRead = 0
        self.totalBytesWritten = 0
        super.init()
    }

    init(downloadPath: String, uploadPath: String, data: NSData) {
        self.downloadURL = NSURL(string: downloadPath)!
        self.uploadURL = NSURL(string: uploadPath)!
        self.data = data

        self.username = ""
        self.password = ""

        self.totalBytesRead = 0
        self.totalBytesWritten = 0
        super.init()
    }

    init(username: String, password: String, downloadPath: String, uploadPath: String, data: NSData) {
        self.downloadURL = NSURL(string: downloadPath)!
        self.uploadURL = NSURL(string: uploadPath)!
        self.data = data

        self.username = username
        self.password = password

        self.totalBytesRead = 0
        self.totalBytesWritten = 0
        super.init()
    }

    //==============================================================================================
    //===========================================Download===========================================
    //==============================================================================================
    func startDownload() {
        self.isDownload = true
        self.delegate.HTOpening?(self.isDownload!)

        let readStream = CFReadStreamCreateWithFTPURL(nil, self.downloadURL)
        CFReadStreamScheduleWithRunLoop(readStream.takeUnretainedValue(), CFRunLoopGetMain(), kCFRunLoopDefaultMode)
        let stream: NSInputStream = readStream.takeRetainedValue()
        self.OpenStream(stream)
    }

    func stopDownload() {
        self.delegate.HTClose?(self.isDownload!)
        self.CloseStream()
    }

    //==============================================================================================
    //=============================================Upload===========================================
    //==============================================================================================
    func startUpload() {
        self.isDownload = false
        self.delegate.HTOpening?(self.isDownload!)

        let writeStream = CFWriteStreamCreateWithFTPURL(nil, self.uploadURL)
        CFWriteStreamScheduleWithRunLoop(writeStream.takeUnretainedValue(), CFRunLoopGetMain(), kCFRunLoopDefaultMode)
        let stream: NSOutputStream = writeStream.takeRetainedValue()
        self.OpenStream(stream)
    }

    func stopUpload() {
        self.delegate.HTClose?(self.isDownload!)
        self.CloseStream()
    }

    //==============================================================================================
    //===================================NSStreamDelegate Methods===================================
    //==============================================================================================
    func stream(aStream: NSStream, handleEvent eventCode: NSStreamEvent) {
        switch (eventCode) {
        case NSStreamEvent.OpenCompleted:
            self.OpenCompleted(self.isDownload!)
            break
        case NSStreamEvent.HasBytesAvailable:
            self.HasBytesAvailable(aStream)
            break
        case NSStreamEvent.HasSpaceAvailable:
            self.HasSpaceAvailable(aStream)
            break
        case NSStreamEvent.ErrorOccurred:
            self.ErrorOccurred(self.isDownload!, error: NSStreamEvent.ErrorOccurred)
            break
        case NSStreamEvent.EndEncountered:
            self.EndEncountered(self.isDownload!)
            break
        case NSStreamEvent.None:
            self.None(self.isDownload!, event: NSStreamEvent.None)
            break
        default:
            self.None(self.isDownload!, event: NSStreamEvent.None)
            break
        }
    }

    //==============================================================================================
    //======================================Streaming Operations====================================
    //==============================================================================================
    private func ConfigureStream(stream: NSStream) {
        stream.setProperty(true, forKey: kCFStreamPropertyShouldCloseNativeSocket as String)
        stream.setProperty(true, forKey: kCFStreamPropertyFTPFetchResourceInfo as String)
        stream.setProperty(true, forKey: kCFStreamPropertyFTPUsePassiveMode as String)

        if (self.username != "" || self.password != "") {
            stream.setProperty(self.username, forKey: kCFStreamPropertyFTPUserName as String)
            stream.setProperty(self.password, forKey: kCFStreamPropertyFTPPassword as String)
        }

        stream.delegate = self
    }

    private func OpenStream(stream: NSStream) {
        self.currentStream = stream
        self.ConfigureStream(self.currentStream!)
        self.currentStream!.scheduleInRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)
        self.currentStream!.open()
    }

    private func CloseStream() {
        self.currentStream?.close()
        self.currentStream!.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
        self.currentStream = nil
        self.Clean()
    }

    //==============================================================================================
    //========================================Streaming Events======================================
    //==============================================================================================
    private func OpenCompleted(isDownload: Bool) {
        self.delegate.HTOpen?(isDownload)
    }

    private func HasBytesAvailable(stream: NSStream) {
        if let inputStream = stream as? NSInputStream {
            let bytesRead = inputStream.read(UnsafeMutablePointer<UInt8>(self.data.bytes), maxLength: self.data.length)
            self.totalBytesRead += bytesRead
            self.delegate.HTDownload?(bytesRead, totalBytesRead: self.totalBytesRead, totalBytesExpectedToRead: self.data.length)
        }
    }

    private func HasSpaceAvailable(stream: NSStream) {
        if let outputStream = stream as? NSOutputStream {
            let bytesWritten = outputStream.write(UnsafePointer<UInt8>(self.data.bytes), maxLength: self.data.length)
            self.totalBytesWritten += bytesWritten
            self.delegate.HTUpload?(bytesWritten, totalBytesWritten: self.totalBytesWritten, totalBytesExpectedToWrite: self.data.length)
        }
    }

    private func ErrorOccurred(isDownload: Bool, error: NSStreamEvent) {
        self.delegate.HTError?(isDownload, error: error)
        self.CloseStream()
    }

    private func EndEncountered(isDownload: Bool) {
        self.delegate.HTComplete?(isDownload)
        self.CloseStream()
    }

    private func None(isDownload: Bool, event: NSStreamEvent) {
        self.delegate.HTUnknown?(isDownload, event: event)
    }

    //==============================================================================================
    //=============================================Clean============================================
    //==============================================================================================
    private func Clean() {
        self.totalBytesRead = 0
        self.totalBytesWritten = 0
    }
    
}</code></pre>
    </main>
  </body>
</html>
